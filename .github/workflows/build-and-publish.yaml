name: Build rust program and publish as GitHub release

on:
  workflow_call:
    inputs:
      skip-target:
        description: 'Targets that should not build against, as array of strings. By default all tier 1 and 2 rust targets will be built.'
        type: string
        default: "[]"
      target-regex:
        description: 'Only build targets matching such regex.'
        type: string
        default: "^([^-]+)-([^-]+)-([^-]+)(-([^-]+))?$"
      binary-name:
        description: 'Rust package name'
        required: true
        type: string
      test-reproducibility:
        description: 'Whether to check if binary is reproducible.'
        type: boolean
        default: true
      fail-if-unreproducible:
        description: 'Whether to fail workflow if binary is unreproducible. Unreproducible binaries are logged but not failed by default.'
        type: boolean
        default: false
      cargo-verbose:
        description: 'Whether or not display extra detailed messages for Cargo.'
        type: boolean
        default: false
      reprotest-verbose:
        description: 'Level of verbosity for reprotest. 0~2 supported.'
        type: number
        default: 1

jobs:
  calculate-matrix:
    name: "Filter targets to build using regex"
    runs-on: ubuntu-latest
    env:
      TARGETS: |
        # Tier 1 with Host Tools
        aarch64-unknown-linux-gnu           # ARM64 Linux (kernel 4.1, glibc 2.17+)
        i686-pc-windows-gnu                 # 32-bit MinGW (Windows 10+, Windows Server 2016+, Pentium 4)
        i686-unknown-linux-gnu              # 32-bit Linux (kernel 3.2+, glibc 2.17+, Pentium 4)
        x86_64-pc-windows-gnu               # 64-bit MinGW (Windows 10+, Windows Server 2016+)
        x86_64-unknown-linux-gnu            # 64-bit Linux (kernel 3.2+, glibc 2.17+)
        # Tier 2 with Host Tools
        aarch64-unknown-linux-musl          # ARM64 Linux with musl 1.2.3
        arm-unknown-linux-gnueabi           # Armv6 Linux (kernel 3.2, glibc 2.17)
        arm-unknown-linux-gnueabihf         # Armv6 Linux, hardfloat (kernel 3.2, glibc 2.17)
        armv7-unknown-linux-gnueabihf       # Armv7-A Linux, hardfloat (kernel 3.2, glibc 2.17)
        loongarch64-unknown-linux-gnu       # LoongArch64 Linux, LP64D ABI (kernel 5.19, glibc 2.36)
        loongarch64-unknown-linux-musl      # LoongArch64 Linux, LP64D ABI (kernel 5.19, musl 1.2.5)
        powerpc-unknown-linux-gnu           # PowerPC Linux (kernel 3.2, glibc 2.17)
        powerpc64-unknown-linux-gnu         # PPC64 Linux (kernel 3.2, glibc 2.17)
        powerpc64le-unknown-linux-gnu       # PPC64LE Linux (kernel 3.10, glibc 2.17)
        riscv64gc-unknown-linux-gnu         # RISC-V Linux (kernel 4.20, glibc 2.29)
        s390x-unknown-linux-gnu             # S390x Linux (kernel 3.2, glibc 2.17)
        x86_64-unknown-freebsd              # 64-bit x86 FreeBSD
        x86_64-unknown-illumos              # illumos
        x86_64-unknown-linux-musl           # 64-bit Linux with musl 1.2.3
        x86_64-unknown-netbsd               # NetBSD/amd64
        # Tier 2 without Host Tools
        aarch64-linux-android               # ARM64 Android
        arm-linux-androideabi               # Armv6 Android
        arm-unknown-linux-musleabi          # Armv6 Linux with musl 1.2.3
        arm-unknown-linux-musleabihf        # Armv6 Linux with musl 1.2.3, hardfloat
        armv5te-unknown-linux-gnueabi       # Armv5TE Linux (kernel 4.4, glibc 2.23)
        armv5te-unknown-linux-musleabi      # Armv5TE Linux with musl 1.2.3
        armv7-linux-androideabi             # Armv7-A Android
        armv7-unknown-linux-gnueabi         # Armv7-A Linux (kernel 4.15, glibc 2.27)
        armv7-unknown-linux-musleabi        # Armv7-A Linux with musl 1.2.3
        armv7-unknown-linux-musleabihf      # Armv7-A Linux with musl 1.2.3, hardfloat
        i586-unknown-linux-gnu              # 32-bit Linux w/o SSE (kernel 3.2, glibc 2.17)
        i586-unknown-linux-musl             # 32-bit Linux w/o SSE, musl 1.2.3
        i686-linux-android                  # 32-bit x86 Android (Pentium 4 plus various extensions)
        i686-unknown-freebsd                # 32-bit x86 FreeBSD (Pentium 4)
        sparc64-unknown-linux-gnu           # SPARC Linux (kernel 4.4, glibc 2.23)
        # https://github.com/cross-rs/cross/issues/1599
        #sparcv9-sun-solaris                 # SPARC V9 Solaris 11.4
        thumbv7neon-linux-androideabi       # Thumb2-mode Armv7-A Android with NEON
        thumbv7neon-unknown-linux-gnueabihf # Thumb2-mode Armv7-A Linux with NEON (kernel 4.4, glibc 2.23)
        wasm32-unknown-emscripten           # WebAssembly via Emscripten
        x86_64-linux-android                # 64-bit x86 Android
        # https://github.com/cross-rs/cross/issues/1599
        #x86_64-pc-solaris                   # 64-bit x86 Solaris 11.4
    outputs:
      targets: ${{ steps.calculate.outputs.filtered_targets }}
    steps:
      - id: calculate
        name: "Filter targets"
        env:
          REGEX: "${{ inputs.target-regex }}"
        run: |
              filtered=""
              while read -r target; do
                # Trim comments
                target="${target%%\#*}"
                # Trim whitespaces
                target="$(echo "$target" | xargs)"
                # Do not run on empty lines
                if [ "$target" == "" ]; then continue; fi
                if [[ "$target" =~ $REGEX ]]; then filtered="${filtered}${target};"; fi
              done <<< "$TARGETS"
              filtered="${filtered%\;}"
              echo "Following targets will be built: ${filtered}"
              echo -n "filtered_targets=" >> "$GITHUB_OUTPUT"
              echo -n "$filtered" | jq --raw-input --slurp --compact-output 'split(";")' >> "$GITHUB_OUTPUT"

  generate-releasenotes:
    name: "Generate changelog from Semantic Commits"
    runs-on: ubuntu-latest
    outputs:
      changelog: "${{ steps.cog.outputs.changelog }}"
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: "Install rust toolchain"
        uses: dtolnay/rust-toolchain@stable
      - name: "Install cocogitto"
        env:
          RUSTFLAGS: "-C opt-level=0 -C panic=abort -C target-cpu=native"
        run:  cargo install cocogitto
      - name: "Generate changelog"
        id:   cog
        run: |
              changelog="$(cog changelog --template full_hash "$(git rev-list -n 1 "$(git describe --tags --abbrev=0)").." \
                || (echo "#### Commits"; git log --oneline \
                  "$(git describe --tags --abbrev=0 "$(git describe --tags --abbrev=0)"^)..$(git describe --tags --abbrev=0)"))"
              {
                echo "changelog<<EOF"
                if [ -f "RELEASE_NOTES.pre.md" ]; then
                  sed s/"EOF"//g RELEASE_NOTES.pre.md
                fi
                echo "${changelog/EOF/}"
                if [ -f "RELEASE_NOTES.md" ]; then
                  sed s/"EOF"//g RELEASE_NOTES.md
                fi
                echo EOF
              } >> "$GITHUB_OUTPUT"
              unset changelog

  publish-release:
    permissions:
      contents: write      # action-gh-release (write)
    name: "Create GitHub release and publish changelog"
    runs-on: ubuntu-latest
    needs: generate-releasenotes
    steps:
      - name: Create release
        uses: softprops/action-gh-release@master
        with:
          body: "${{ needs.generate-releasenotes.outputs.changelog }}"

  build-and-upload:
    permissions:
      contents: write      # attest-build-provenance (read), action-gh-release (write)
      id-token: write      # attest-build-provenance
      attestations: write  # attest-build-provenance
    name: "Compile and upload artifact"
    runs-on: ubuntu-latest
    needs: ["publish-release", "calculate-matrix"]
    strategy:
      fail-fast: false
      matrix:
        target: ${{ fromJSON(needs.calculate-matrix.outputs.targets) }}
        exclude: ${{ fromJSON(inputs.skip-target) }}
    steps:
      - name: "Checkout"
        uses: actions/checkout@master
      - name: "Install rust toolchain"
        uses: dtolnay/rust-toolchain@stable
      - name: "Install cross-compilation tool"
        env:
          RUSTFLAGS: "-C opt-level=0 -C panic=abort -C target-cpu=native"
        run:  cargo install cross --git "https://github.com/cross-rs/cross"
      - name: "Build for target ${{ matrix.target }}"
        if:   "${{ !inputs.test-reproducibility }}"
        env:
          TARGET: "${{ matrix.target }}"
          BINARY: "${{ inputs.binary-name }}"
          CARGO_TERM_VERBOSE: "${{ inputs.cargo-verbose }}"
        run: cross build --release "--target=$TARGET"
      - name: "Build for target ${{ matrix.target }} and check for reproducibility"
        if:   "${{ inputs.test-reproducibility }}"
        env:
          TARGET: "${{ matrix.target }}"
          BINARY: "${{ inputs.binary-name }}"
          CARGO_TERM_VERBOSE: "${{ inputs.cargo-verbose }}"
          REPROTEST_VERBOSE: "${{ inputs.reprotest-verbose }}"
          FAIL_IF_UNREPRODUCIBLE: "${{ inputs.fail-if-unreproducible }}"
        run: |
              dockerfile="$(mktemp)"
              {
                echo "ARG CROSS_BASE_IMAGE"
                echo "FROM \$CROSS_BASE_IMAGE"
                echo "RUN apt-get update >/dev/null 2>&1"
                echo "RUN apt-get install --yes reprotest diffoscope >/dev/null 2>&1"
                # Stub setarch as it doesn't work in docker
                echo "RUN echo '#!/bin/sh' > /usr/bin/setarch"
                echo "RUN echo 'shift; while [ \"\${1##-*}\" = \"\" ] && [ \"\$1\" != \"\" ]; do shift; done' >> /usr/bin/setarch"
                echo "RUN echo 'exec \"\$@\"' >> /usr/bin/setarch"
                echo "RUN chmod +x /usr/bin/setarch"
              } >> "$dockerfile"
              CROSS_BUILD_DOCKERFILE="$dockerfile" cross-util run "--target=$TARGET" -- \
                "reprotest \"--verbosity=$REPROTEST_VERBOSE\" \
                \"rm -rf /target && cargo build --release \\\"--target=$TARGET\\\" \\\"--package=$BINARY\\\" && find /target -name "*.d" -delete\" \
                \"/target/${TARGET}/release/${BINARY}*\" && touch REPRODUCIBLE || touch NONREPRODUCIBLE"
              if [ -f REPRODUCIBLE ]; then
                echo "REPRODUCIBLE=true" >> "$GITHUB_ENV"
              elif [ -f NONREPRODUCIBLE ]; then
                echo "REPRODUCIBLE=false" >> "$GITHUB_ENV"
                if [ "$FAIL_IF_UNREPRODUCIBLE" == "true" ]; then
                  echo "::error ::Binary is not reproducible"
                  exit 1
                fi
              else
                echo "::error ::Failed to run reprotest"
                exit 1
              fi
      - name: "Generate reproducibility report"
        id:   reproducible-report
        env:
          TARGET: "${{ matrix.target }}"
          BINARY: "${{ inputs.binary-name }}"
        run: |
              if [ "$REPRODUCIBLE" == "true" ]; then
                echo "reproducible=✅  $BINARY is reproducible for $TARGET" >> "$GITHUB_OUTPUT"
              elif [ "$REPRODUCIBLE" == "false" ]; then
                echo "reproducible=❌  $BINARY is not reproducible for $TARGET" >> "$GITHUB_OUTPUT"
              fi
      - name: "Rename build artifact"
        id: move-artifact
        env:
          TARGET: "${{ matrix.target }}"
          BINARY: "${{ inputs.binary-name }}"
        run:  |
          release_path_unix="target/${TARGET}/release/${BINARY}"
          release_path_win="${release_path_unix}.exe"
          release_path_js="${release_path_unix}.js"
          target_path_unix="target/${BINARY}-${TARGET}"
          target_path_win="${target_path_unix}.exe"
          target_path_js="${target_path_unix}.js"
          if [ -f "$release_path_unix" ]; then
            mv "$release_path_unix" "$target_path_unix"
            echo "TARGET_PATH=$target_path_unix" >> "$GITHUB_OUTPUT"
          elif [ -f "$release_path_win" ]; then
            mv "$release_path_win" "$target_path_win"
            echo "TARGET_PATH=$target_path_win" >> "$GITHUB_OUTPUT"
          elif [ -f "$release_path_js" ]; then
            mv "$release_path_js" "$target_path_js"
            echo "TARGET_PATH=$target_path_js" >> "$GITHUB_OUTPUT"
          else
            echo "::error ::Build artifact not found"
            echo "Possible files in target/ directory:"
            find target -type f 2>/dev/null
            exit 1
          fi
      - name: "Generate build provenance attestation"
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: "${{ steps.move-artifact.outputs.TARGET_PATH }}"
      - name: "Upload binary as artifact"
        uses: softprops/action-gh-release@master
        with:
          files: "${{ steps.move-artifact.outputs.TARGET_PATH }}"
          body: "${{ steps.reproducible-report.outputs.reproducible }}"
          append_body: true
