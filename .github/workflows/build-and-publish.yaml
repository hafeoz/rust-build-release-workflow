name: Build rust program and publish as GitHub release

on:
  workflow_call:
    inputs:
      target-regex:
        description: 'Only build targets matching regex specified.
                      By default all GUN Target Triplet-conforming targets are considered.'
        type: string
        default: '^([^-]+)-([^-]+)-([^-]+)(-([^-]+))?$'
      skip-target:
        description: 'Targets that should not build against, as array of strings.
                      By default all tier 1 and 2 rust targets will be built.'
        type: string
        default: '[]'
      executable-filter:
        description: 'jq filter that extract executable path from cargo json messages.'
        type: string
        default: '.[] |
          select(
            (.reason == "compiler-artifact") and
            (.executable != null) and
            (.target.kind == ["bin"])
          ) | .executable'
      rust-toolchain:
        description: 'Rust toolchain to use.'
        type: string
        default: 'nightly'
      rust-flags:
        description: 'RUSTFLAGS environment variable used when compilation.'
        type: string
        default: '-Z remap-cwd-prefix=.'
      test-reproducibility:
        description: 'Whether to check if binary is reproducible.'
        type: boolean
        default: true
      reprotest-variations:
        description: 'Variations to test for reproducibility, as comma-separated of strings.
                      By default all variations except time (cause rustc to SIGSEGV) and domain_host (unsupported for GitHub runner) is enabled.
                      Note user_group and domain_host is currently not supported.'
        type: string
        default: '+all,-time,-domain_host'
      fail-if-unreproducible:
        description: 'Whether to fail the workflow if binary is unreproducible.
                      By default unreproducible binaries are warned but not failed.'
        type: boolean
        default: false
      cargo-verbose:
        description: 'Whether or not display extra detailed messages for Cargo.'
        type: boolean
        default: false
      reprotest-verbose:
        description: 'Level of verbosity (0~2) for reprotest.'
        type: number
        default: 1

jobs:
  calculate-matrix:
    name: 'Filter targets to build'
    runs-on: ubuntu-latest
    env:
      TARGETS: |
        # Tier 1 with Host Tools
        aarch64-unknown-linux-gnu           # ARM64 Linux (kernel 4.1, glibc 2.17+)
        i686-pc-windows-gnu                 # 32-bit MinGW (Windows 10+, Windows Server 2016+, Pentium 4)
        i686-unknown-linux-gnu              # 32-bit Linux (kernel 3.2+, glibc 2.17+, Pentium 4)
        x86_64-pc-windows-gnu               # 64-bit MinGW (Windows 10+, Windows Server 2016+)
        x86_64-unknown-linux-gnu            # 64-bit Linux (kernel 3.2+, glibc 2.17+)
        # Tier 2 with Host Tools
        aarch64-unknown-linux-musl          # ARM64 Linux with musl 1.2.3
        arm-unknown-linux-gnueabi           # Armv6 Linux (kernel 3.2, glibc 2.17)
        arm-unknown-linux-gnueabihf         # Armv6 Linux, hardfloat (kernel 3.2, glibc 2.17)
        armv7-unknown-linux-gnueabihf       # Armv7-A Linux, hardfloat (kernel 3.2, glibc 2.17)
        loongarch64-unknown-linux-gnu       # LoongArch64 Linux, LP64D ABI (kernel 5.19, glibc 2.36)
        loongarch64-unknown-linux-musl      # LoongArch64 Linux, LP64D ABI (kernel 5.19, musl 1.2.5)
        powerpc-unknown-linux-gnu           # PowerPC Linux (kernel 3.2, glibc 2.17)
        powerpc64-unknown-linux-gnu         # PPC64 Linux (kernel 3.2, glibc 2.17)
        powerpc64le-unknown-linux-gnu       # PPC64LE Linux (kernel 3.10, glibc 2.17)
        riscv64gc-unknown-linux-gnu         # RISC-V Linux (kernel 4.20, glibc 2.29)
        s390x-unknown-linux-gnu             # S390x Linux (kernel 3.2, glibc 2.17)
        x86_64-unknown-freebsd              # 64-bit x86 FreeBSD
        x86_64-unknown-illumos              # illumos
        x86_64-unknown-linux-musl           # 64-bit Linux with musl 1.2.3
        x86_64-unknown-netbsd               # NetBSD/amd64
        # Tier 2 without Host Tools
        aarch64-linux-android               # ARM64 Android
        arm-linux-androideabi               # Armv6 Android
        arm-unknown-linux-musleabi          # Armv6 Linux with musl 1.2.3
        arm-unknown-linux-musleabihf        # Armv6 Linux with musl 1.2.3, hardfloat
        armv5te-unknown-linux-gnueabi       # Armv5TE Linux (kernel 4.4, glibc 2.23)
        armv5te-unknown-linux-musleabi      # Armv5TE Linux with musl 1.2.3
        armv7-linux-androideabi             # Armv7-A Android
        armv7-unknown-linux-gnueabi         # Armv7-A Linux (kernel 4.15, glibc 2.27)
        armv7-unknown-linux-musleabi        # Armv7-A Linux with musl 1.2.3
        armv7-unknown-linux-musleabihf      # Armv7-A Linux with musl 1.2.3, hardfloat
        i586-unknown-linux-gnu              # 32-bit Linux w/o SSE (kernel 3.2, glibc 2.17)
        i586-unknown-linux-musl             # 32-bit Linux w/o SSE, musl 1.2.3
        i686-linux-android                  # 32-bit x86 Android (Pentium 4 plus various extensions)
        i686-unknown-freebsd                # 32-bit x86 FreeBSD (Pentium 4)
        sparc64-unknown-linux-gnu           # SPARC Linux (kernel 4.4, glibc 2.23)
        # BUG: https://github.com/cross-rs/cross/issues/1599
        # sparcv9-sun-solaris               # SPARC V9 Solaris 11.4
        thumbv7neon-linux-androideabi       # Thumb2-mode Armv7-A Android with NEON
        thumbv7neon-unknown-linux-gnueabihf # Thumb2-mode Armv7-A Linux with NEON (kernel 4.4, glibc 2.23)
        wasm32-unknown-emscripten           # WebAssembly via Emscripten
        x86_64-linux-android                # 64-bit x86 Android
        # BUG: https://github.com/cross-rs/cross/issues/1599
        # x86_64-pc-solaris                 # 64-bit x86 Solaris 11.4
    outputs:
      targets: '${{ steps.calculate.outputs.filtered_targets }}'
    steps:
      - name: 'Filter targets'
        id: calculate
        env:
          REGEX: '${{ inputs.target-regex }}'
        run: |
          filtered=""
          while read -r triple; do
            # Trim comments
            triple="${triple%%\#*}"
            # Trim whitespaces
            triple="$(echo "$triple" | xargs)"
            if [[ "$triple" =~ $REGEX ]]; then filtered="${filtered}${triple};"; fi
          done <<< "$TARGETS"
          echo -n "filtered_targets=" >> "$GITHUB_OUTPUT"
          echo -n "${filtered%\;}" | jq -Rsc 'split(";")' >> "$GITHUB_OUTPUT"

  generate-releasenotes:
    name: 'Generate changelog'
    runs-on: ubuntu-latest
    outputs:
      changelog: '${{ steps.cog.outputs.changelog }}'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch whole git history
      - name: 'Install rust toolchain'
        uses: dtolnay/rust-toolchain@stable
      - name: 'Install cocogitto'
        env:
          RUSTFLAGS: '-C opt-level=0 -C panic=abort -C target-cpu=native'
        run: cargo install cocogitto
      - name: 'Generate changelog'
        id: cog
        run: |
          latest_tag="$(git describe --tags --abbrev=0)"
          prev_tag="$(git describe --tags --abbrev=0 "$latest_tag"^)"

          print_strip_eof() { sed s/"EOF"//g "$1"; }

          cog_changelog() { cog changelog --template full_hash --at "$latest_tag"; }
          git_changelog() { echo "### $latest_tag"; echo "#### Commits"; git log --oneline "${prev_tag}..${latest_tag}"; }
          changelog="$(cog_changelog || git_changelog)"

          {
            echo "changelog<<EOF"

            if [ -f "RELEASE_NOTES.pre.md" ]; then print_strip_eof "RELEASE_NOTES.pre.md"; fi
            echo "${changelog/EOF/}"
            if [ -f "RELEASE_NOTES.md" ]; then print_strip_eof "RELEASE_NOTES.md"; fi

            echo EOF
          } >> "$GITHUB_OUTPUT"

  publish-release:
    permissions:
      contents: write # action-gh-release (write)
    name: 'Create GitHub release and publish release notes'
    runs-on: ubuntu-latest
    needs: generate-releasenotes
    steps:
      - uses: softprops/action-gh-release@master
        with:
          body: '${{ needs.generate-releasenotes.outputs.changelog }}'

  build-and-upload:
    permissions:
      contents: write # attest-build-provenance (read), action-gh-release (write)
      id-token: write # attest-build-provenance
      attestations: write # attest-build-provenance
    name: 'Compile and upload artifact'
    runs-on: ubuntu-latest
    needs: ["publish-release", "calculate-matrix"]
    strategy:
      fail-fast: false
      matrix:
        target: '${{ fromJSON(needs.calculate-matrix.outputs.targets) }}'
        exclude: '${{ fromJSON(inputs.skip-target) }}'
    steps:
      - uses: actions/checkout@master
      - name: 'Install rust toolchain'
        uses: dtolnay/rust-toolchain@master
        with:
          toolchain: '${{ inputs.rust-toolchain }}'
      - name: 'Install rust-cross'
        env:
          RUSTFLAGS: "-C opt-level=0 -C panic=abort -C target-cpu=native"
        run: cargo install cross --git 'https://github.com/cross-rs/cross'
      - name: 'Evaluate RUSTFLAGS for rust-cross'
        env:
          TARGET: '${{ matrix.target }}'
          RUSTFLAGS: '${{ inputs.rust-flags }}'
        run: |
          {
            echo "CARGO_TARGET_$(echo "$TARGET" | tr '[:lower:]' '[:upper:]' | tr '-' '_' )_RUSTFLAGS<<EOF"
            echo "${RUSTFLAGS/EOF/}"
            echo EOF
          } >> "$GITHUB_ENV"
      - name: 'Build for target ${{ matrix.target }} without reproducibility test'
        if: '${{ !inputs.test-reproducibility }}'
        env:
          TARGET: '${{ matrix.target }}'
          CARGO_TERM_VERBOSE: '${{ inputs.cargo-verbose }}'
          EXECUTABLE_FILTER: '${{ inputs.executable-filter }}'
        run: |
          cross build --release "--target=$TARGET"
          mkdir target_executables
          cross build --release "--target=$TARGET" --message-format=json | jq -s --raw-output0 "$EXECUTABLE_FILTER" | while IFS= read -r -d $'\0' file; do
            cp "$file" ./target_executables/
          done
      - name: 'Build for target ${{ matrix.target }} and test for reproducibility'
        if: '${{ inputs.test-reproducibility }}'
        env:
          TARGET: '${{ matrix.target }}'
          CARGO_TERM_VERBOSE: '${{ inputs.cargo-verbose }}'
          REPROTEST_VERBOSE: '${{ inputs.reprotest-verbose }}'
          FAIL_IF_UNREPRODUCIBLE: '${{ inputs.fail-if-unreproducible }}'
          REPROTEST_VARY: '${{ inputs.reprotest-variations }}'
          CROSS_CONTAINER_OPTS: '--privileged' # fuse driver needs privileged container; not a security problem since we're docker-in-docker
          SETARCH_STUB: |
            #!/bin/sh
            # setarch [arch] [options] [program [argument...]]
            # A small script that replace setarch(8) with a dumb program caller - setarch is not supported in GitHub docker
            shift; while [ "${1##-*}" = "" ] && [ "$1" != "" ]; do shift; done
            exec "$@"
          CROSS_DOCKERFILE: |
            ARG CROSS_BASE_IMAGE
            FROM $CROSS_BASE_IMAGE
            RUN apt-get update >/dev/null 2>&1
            RUN apt-get install --yes reprotest diffoscope jq >/dev/null 2>&1
            COPY --chmod=555 setarch_stub /usr/bin/setarch
          COMPILER: |
            #!/usr/bin/env bash
            set -o errexit -o nounset -o pipefail
            env CARGO_TARGET_DIR=./targets \
              cargo build --release "--target=${{ matrix.target }}"
            mkdir target_executables
            env CARGO_TARGET_DIR=./targets \
              cargo build --release "--target=${{ matrix.target }}" --message-format=json \
              | jq -s --raw-output0 "${{ inputs.executable-filter }}" \
              | while IFS= read -r -d $'\0' file; do
                cp "$file" ./target_executables/
              done
          MOVE_FILES: >
            find "$CARGO_TARGET_DIR" -mindepth 1 -delete;
            find target_executables/ -exec mv -t "$CARGO_TARGET_DIR" {} +
        run: |
          dockerfile="$(mktemp)"
          echo "$SETARCH_STUB" > setarch_stub
          echo "$CROSS_DOCKERFILE" > "$dockerfile"
          echo "$COMPILER" > compile.sh
          # WORKAROUND: add current user and group to database to make fusermount happy
          {
            echo "RUN groupadd --gid \"$(id --group)\" --non-unique \"$(id --group --name)\""
            echo "RUN useradd --non-unique --uid \"$(id --user)\" --gid \"$(id --group)\" \"$(id --user --name)\" "
          } >> "$dockerfile"

          env \
          CROSS_BUILD_DOCKERFILE="$dockerfile" \
            cross-util run "--target=$TARGET" -- \
              "reprotest \"--verbosity=$REPROTEST_VERBOSE\" \"--variations=$REPROTEST_VARY\" \"bash compile.sh\" \"target_executables/*\" && touch REPRODUCIBLE; $MOVE_FILES"
          mv target target_executables

          if [ -f REPRODUCIBLE ]; then
            echo "REPRODUCIBLE=true" >> "$GITHUB_ENV"
          else
            echo "REPRODUCIBLE=false" >> "$GITHUB_ENV"
            if [ "$FAIL_IF_UNREPRODUCIBLE" == "true" ]; then
              echo "::error::Binary is not reproducible"
              exit 1
            fi
          fi
      - name: 'Generate reproducibility report'
        id: reproducible-report
        env:
          TARGET: '${{ matrix.target }}'
        run: |
          if [ "$REPRODUCIBLE" == "true" ]; then
            echo "reproducible=✅  ${TARGET}'s binary is reproducible" >> "$GITHUB_OUTPUT"
          elif [ "$REPRODUCIBLE" == "false" ]; then
            echo "reproducible=❌  ${TARGET}'s binary is not reproducible" >> "$GITHUB_OUTPUT"
          fi
      - name: 'Rename build artifact'
        env:
          TARGET: '${{ matrix.target }}'
        run: find target_executables -type f -exec mv -v '{}' "{}-$TARGET" \;
      - name: 'Generate build provenance attestation'
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: 'target_executables/*'
      - name: 'Upload binary as artifact'
        uses: softprops/action-gh-release@master
        with:
          files: 'target_executables/*'
          body: '${{ steps.reproducible-report.outputs.reproducible }}'
          append_body: true
