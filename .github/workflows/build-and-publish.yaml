name: Build rust program and publish as GitHub release

on:
  workflow_call:
    inputs:
      target-regex:
        description: 'Only build targets matching regex specified.
                      By default all GUN Target Triplet-conforming targets are considered.'
        type: string
        default: '^([^-]+)-([^-]+)-([^-]+)(-([^-]+))?$'
      skip-target:
        description: 'Targets that should not build against, as array of strings.
                      By default all tier 1 and 2 rust targets will be built.'
        type: string
        default: '[]'
      binary-name:
        description: 'Rust program name.'
        required: true
        type: string
      rust-flags:
        description: 'RUSTFLAGS environment variable used when compilation.'
        type: string
        default: '-Z remap-cwd-prefix=.'
      test-reproducibility:
        description: 'Whether to check if binary is reproducible.'
        type: boolean
        default: true
      reprotest-variations:
        description: 'Variations to test for reproducibility, as comma-separated of strings.
                      By default all variations except time (cause rustc to SIGSEGV) and domain_host (unsupported for GitHub runner) is enabled.
                      Note user_group and domain_host is currently not supported.'
        type: string
        default: '+all,-time,-domain_host'
      fail-if-unreproducible:
        description: 'Whether to fail the workflow if binary is unreproducible.
                      By default unreproducible binaries are warned but not failed.'
        type: boolean
        default: false
      cargo-verbose:
        description: 'Whether or not display extra detailed messages for Cargo.'
        type: boolean
        default: false
      reprotest-verbose:
        description: 'Level of verbosity (0~2) for reprotest.'
        type: number
        default: 1

jobs:
  calculate-matrix:
    name: 'Filter targets to build'
    runs-on: ubuntu-latest
    env:
      TARGETS: |
        # Tier 1 with Host Tools
        aarch64-unknown-linux-gnu           # ARM64 Linux (kernel 4.1, glibc 2.17+)
        i686-pc-windows-gnu                 # 32-bit MinGW (Windows 10+, Windows Server 2016+, Pentium 4)
        i686-unknown-linux-gnu              # 32-bit Linux (kernel 3.2+, glibc 2.17+, Pentium 4)
        x86_64-pc-windows-gnu               # 64-bit MinGW (Windows 10+, Windows Server 2016+)
        x86_64-unknown-linux-gnu            # 64-bit Linux (kernel 3.2+, glibc 2.17+)
        # Tier 2 with Host Tools
        aarch64-unknown-linux-musl          # ARM64 Linux with musl 1.2.3
        arm-unknown-linux-gnueabi           # Armv6 Linux (kernel 3.2, glibc 2.17)
        arm-unknown-linux-gnueabihf         # Armv6 Linux, hardfloat (kernel 3.2, glibc 2.17)
        armv7-unknown-linux-gnueabihf       # Armv7-A Linux, hardfloat (kernel 3.2, glibc 2.17)
        loongarch64-unknown-linux-gnu       # LoongArch64 Linux, LP64D ABI (kernel 5.19, glibc 2.36)
        loongarch64-unknown-linux-musl      # LoongArch64 Linux, LP64D ABI (kernel 5.19, musl 1.2.5)
        powerpc-unknown-linux-gnu           # PowerPC Linux (kernel 3.2, glibc 2.17)
        powerpc64-unknown-linux-gnu         # PPC64 Linux (kernel 3.2, glibc 2.17)
        powerpc64le-unknown-linux-gnu       # PPC64LE Linux (kernel 3.10, glibc 2.17)
        riscv64gc-unknown-linux-gnu         # RISC-V Linux (kernel 4.20, glibc 2.29)
        s390x-unknown-linux-gnu             # S390x Linux (kernel 3.2, glibc 2.17)
        x86_64-unknown-freebsd              # 64-bit x86 FreeBSD
        x86_64-unknown-illumos              # illumos
        x86_64-unknown-linux-musl           # 64-bit Linux with musl 1.2.3
        x86_64-unknown-netbsd               # NetBSD/amd64
        # Tier 2 without Host Tools
        aarch64-linux-android               # ARM64 Android
        arm-linux-androideabi               # Armv6 Android
        arm-unknown-linux-musleabi          # Armv6 Linux with musl 1.2.3
        arm-unknown-linux-musleabihf        # Armv6 Linux with musl 1.2.3, hardfloat
        armv5te-unknown-linux-gnueabi       # Armv5TE Linux (kernel 4.4, glibc 2.23)
        armv5te-unknown-linux-musleabi      # Armv5TE Linux with musl 1.2.3
        armv7-linux-androideabi             # Armv7-A Android
        armv7-unknown-linux-gnueabi         # Armv7-A Linux (kernel 4.15, glibc 2.27)
        armv7-unknown-linux-musleabi        # Armv7-A Linux with musl 1.2.3
        armv7-unknown-linux-musleabihf      # Armv7-A Linux with musl 1.2.3, hardfloat
        i586-unknown-linux-gnu              # 32-bit Linux w/o SSE (kernel 3.2, glibc 2.17)
        i586-unknown-linux-musl             # 32-bit Linux w/o SSE, musl 1.2.3
        i686-linux-android                  # 32-bit x86 Android (Pentium 4 plus various extensions)
        i686-unknown-freebsd                # 32-bit x86 FreeBSD (Pentium 4)
        sparc64-unknown-linux-gnu           # SPARC Linux (kernel 4.4, glibc 2.23)
        # BUG: https://github.com/cross-rs/cross/issues/1599
        # sparcv9-sun-solaris               # SPARC V9 Solaris 11.4
        thumbv7neon-linux-androideabi       # Thumb2-mode Armv7-A Android with NEON
        thumbv7neon-unknown-linux-gnueabihf # Thumb2-mode Armv7-A Linux with NEON (kernel 4.4, glibc 2.23)
        wasm32-unknown-emscripten           # WebAssembly via Emscripten
        x86_64-linux-android                # 64-bit x86 Android
        # BUG: https://github.com/cross-rs/cross/issues/1599
        # x86_64-pc-solaris                 # 64-bit x86 Solaris 11.4
    outputs:
      targets: '${{ steps.calculate.outputs.filtered_targets }}'
    steps:
      - name: 'Filter targets'
        id: calculate
        env:
          REGEX: '${{ inputs.target-regex }}'
        run: |
          filtered=""
          while read -r triple; do
            # Trim comments
            triple="${triple%%\#*}"
            # Trim whitespaces
            triple="$(echo "$triple" | xargs)"
            if [[ "$triple" =~ $REGEX ]]; then filtered="${filtered}${triple};"; fi
          done <<< "$TARGETS"
          echo -n "filtered_targets=" >> "$GITHUB_OUTPUT"
          echo -n "${filtered%\;}" | jq -Rsc 'split(";")' >> "$GITHUB_OUTPUT"

  generate-releasenotes:
    name: 'Generate changelog'
    runs-on: ubuntu-latest
    outputs:
      changelog: '${{ steps.cog.outputs.changelog }}'
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Fetch whole git history
      - name: 'Install rust toolchain'
        uses: dtolnay/rust-toolchain@stable
      - name: 'Install cocogitto'
        env:
          RUSTFLAGS: '-C opt-level=0 -C panic=abort -C target-cpu=native'
        run: cargo install cocogitto
      - name: 'Generate changelog'
        id: cog
        run: |
          latest_tag="$(git describe --tags --abbrev=0)"
          prev_tag="$(git describe --tags --abbrev=0 "$latest_tag"^)"

          print_strip_eof() { sed s/"EOF"//g "$1"; }

          cog_changelog() { cog changelog --template full_hash --at "$latest_tag"; }
          git_changelog() { echo "### $latest_tag"; echo "#### Commits"; git log --oneline "${prev_tag}..${latest_tag}"; }
          changelog="$(cog_changelog || git_changelog)"

          {
            echo "changelog<<EOF"

            if [ -f "RELEASE_NOTES.pre.md" ]; then print_strip_eof "RELEASE_NOTES.pre.md"; fi
            echo "${changelog/EOF/}"
            if [ -f "RELEASE_NOTES.md" ]; then print_strip_eof "RELEASE_NOTES.md"; fi

            echo EOF
          } >> "$GITHUB_OUTPUT"

  publish-release:
    permissions:
      contents: write # action-gh-release (write)
    name: 'Create GitHub release and publish release notes'
    runs-on: ubuntu-latest
    needs: generate-releasenotes
    steps:
      - uses: softprops/action-gh-release@master
        with:
          body: '${{ needs.generate-releasenotes.outputs.changelog }}'

  build-and-upload:
    permissions:
      contents: write # attest-build-provenance (read), action-gh-release (write)
      id-token: write # attest-build-provenance
      attestations: write # attest-build-provenance
    name: 'Compile and upload artifact'
    runs-on: ubuntu-latest
    needs: ["publish-release", "calculate-matrix"]
    strategy:
      fail-fast: false
      matrix:
        target: '${{ fromJSON(needs.calculate-matrix.outputs.targets) }}'
        exclude: '${{ fromJSON(inputs.skip-target) }}'
    steps:
      - uses: actions/checkout@master
      - name: 'Install rust toolchain'
        uses: dtolnay/rust-toolchain@stable
      - name: 'Install rust-cross'
        env:
          RUSTFLAGS: "-C opt-level=0 -C panic=abort -C target-cpu=native"
        run: cargo install cross --git 'https://github.com/cross-rs/cross'
      - name: 'Build for target ${{ matrix.target }} without reproducibility test'
        if: '${{ !inputs.test-reproducibility }}'
        env:
          TARGET: '${{ matrix.target }}'
          CARGO_TERM_VERBOSE: '${{ inputs.cargo-verbose }}'
          RUSTFLAGS: '${{ inputs.rust-flags }}'
        run: >
          env "CARGO_TARGET_${TARGET}_RUSTFLAGS=${RUSTFLAGS}"
          cross build --release "--target=$TARGET"
      - name: 'Build for target ${{ matrix.target }} and test for reproducibility'
        if: '${{ inputs.test-reproducibility }}'
        env:
          TARGET: '${{ matrix.target }}'
          CARGO_TERM_VERBOSE: '${{ inputs.cargo-verbose }}'
          REPROTEST_VERBOSE: '${{ inputs.reprotest-verbose }}'
          FAIL_IF_UNREPRODUCIBLE: '${{ inputs.fail-if-unreproducible }}'
          REPROTEST_VARY: '${{ inputs.reprotest-variations }}'
          RELEASE_PATH_GLOB: 'target/${{ matrix.target }}/release/${{ inputs.binary-name }}*'
          RUSTFLAGS: '${{ inputs.rust-flags }}'
          CROSS_CONTAINER_OPTS: '--privileged' # fuse driver needs privileged container; not a security problem since we're docker-in-docker
          SETARCH_STUB: |
            #!/bin/sh
            # setarch [arch] [options] [program [argument...]]
            # A small script that replace setarch(8) with a dumb program caller - setarch is not supported in GitHub docker
            shift; while [ "${1##-*}" = "" ] && [ "$1" != "" ]; do shift; done
            exec "$@"
          CROSS_DOCKERFILE: |
            ARG CROSS_BASE_IMAGE
            FROM $CROSS_BASE_IMAGE
            RUN apt-get update >/dev/null 2>&1
            RUN apt-get install --yes reprotest diffoscope >/dev/null 2>&1
            COPY --chmod 555 /tmp/setarch /usr/bin/setarch
          COMPILE_CMD: >
            CARGO_TARGET_DIR=./target
            cargo build
              --release
              \"--target=${{ matrix.target }}\"
              \"--package=${{ inputs.binary-name }}\"
            && rm -rf \"$CARGO_TARGET_DIR/*\"
            && cp -vaf ./target/. \"$CARGO_TARGET_DIR/\"
        run: |
          dockerfile="$(mktemp)"
          echo "$SETARCH_STUB" > /tmp/setarch
          echo "$CROSS_DOCKERFILE" > "$dockerfile"
          env \
          "CARGO_TARGET_${TARGET}_RUSTFLAGS=${RUSTFLAGS}" \
          CROSS_BUILD_DOCKERFILE="$dockerfile" \
            cross-util run "--target=$TARGET" -- \
              "reprotest \"--verbosity=$REPROTEST_VERBOSE\" \"--variations=$REPROTEST_VARY\" \"$COMPILE_CMD\" \"$RELEASE_PATH_GLOB\" && touch REPRODUCIBLE"
          if [ -f REPRODUCIBLE ]; then
            echo "REPRODUCIBLE=true" >> "$GITHUB_ENV"
          else
            echo "REPRODUCIBLE=false" >> "$GITHUB_ENV"
            if [ "$FAIL_IF_UNREPRODUCIBLE" == "true" ]; then
              echo "::error::Binary is not reproducible"
              exit 1
            fi
          fi
      - name: 'Generate reproducibility report'
        id: reproducible-report
        env:
          TARGET: '${{ matrix.target }}'
          BINARY: '${{ inputs.binary-name }}'
        run: |
          if [ "$REPRODUCIBLE" == "true" ]; then
            echo "reproducible=✅  $BINARY is reproducible for $TARGET" >> "$GITHUB_OUTPUT"
          elif [ "$REPRODUCIBLE" == "false" ]; then
            echo "reproducible=❌  $BINARY is not reproducible for $TARGET" >> "$GITHUB_OUTPUT"
          fi
      - name: 'Rename build artifact'
        id: move-artifact
        env:
          SRC_PATH: 'target/${{ matrix.target }}/release/${{ inputs.binary-name }}'
          DST_PATH: 'target/${{ inputs.binary-name }}-${{ matrix.target }}'
          FIND_NAME: '${{ inputs.binary-name }}*'
        run: |
          if [ -f "$SRC_PATH" ]; then
            mv "$SRC_PATH" "$DST_PATH"
            echo "OUTPUT_PATH=$DST_PATH" >> "$GITHUB_OUTPUT"
          elif [ -f "${SRC_PATH}.exe" ]; then
            mv "${SRC_PATH}.exe" "${DST_PATH}.exe"
            echo "OUTPUT_PATH=${DST_PATH}.exe" >> "$GITHUB_OUTPUT"
          elif [ -f "${SRC_PATH}.js" ]; then
            mv "${SRC_PATH}.js" "${DST_PATH}.js"
            echo "OUTPUT_PATH=${DST_PATH}.js" >> "$GITHUB_OUTPUT"
          else
            echo "::error::Build artifact not found"
            echo "Possible files in target/ directory:"
            find target/ -type f -name "$FIND_NAME" 2>/dev/null
            exit 1
          fi
      - name: 'Generate build provenance attestation'
        uses: actions/attest-build-provenance@v2
        with:
          subject-path: '${{ steps.move-artifact.outputs.OUTPUT_PATH }}'
      - name: 'Upload binary as artifact'
        uses: softprops/action-gh-release@master
        with:
          files: '${{ steps.move-artifact.outputs.OUTPUT_PATH }}'
          body: '${{ steps.reproducible-report.outputs.reproducible }}'
          append_body: true
